@page "/Graphe"
@inject HttpClient Http
@using OfficeOpenXml;
@using System;
@using System.Data;
@using System.Diagnostics;
@using System.Collections.Generic;
@using System.Text;
@using System.IO;
@using Newtonsoft.Json;
@using System.Web;
@using Accord.Math;
@using Accord.Statistics;
@using Plotly.Blazor.LayoutLib;
@using Plotly.Blazor.Traces.ScatterLib
@using Blazor_Layout = Plotly.Blazor.Layout
@using Title = Plotly.Blazor.LayoutLib.Title
@using YAxis = Plotly.Blazor.LayoutLib.YAxis


<body>
    @if (Table.matrixListStatic == null || Table.matrixListStatic[0] == null)
    {
<p><em>Loading...</em></p> }
else
{
<table class="table">
    <thead>
        <tr>
            <th>Name of Indicators</th>
            <th>BetaSR</th>
            <th>Selection</th>
            <th>BetaMR</th>
            <th>Selection</th>

        </tr>
    </thead>
    <tbody>

        @foreach (Indicateur indicateur in listOfSelectedX)
        {
            // On check si l'indicateur a été coché ou pas
@if (indicateur.IsChecked)
{
<tr>
    <td>@indicateur.Nom</td>

    <td>@(Math.Round(indicateur.BetaValueSR * 10000) / 10000)</td>

    <td>
        <input type="checkbox" id="checked" name="checked" @onchange="eventArgs => { PlotSR(indicateur, eventArgs.Value); }">
    </td>

    <td>@(Math.Round(indicateur.BetaValueMR * 10000) / 10000)</td>

    <td>
        <input type="checkbox" id="checked1" name="checked1" @onchange="eventArgs => { PlotMR(indicateur, eventArgs.Value); }">
    </td>
</tr>
}}


    </tbody>
</table>

                <PlotlyChart style="height: 60vh; min-height: 350px; width: 100vh; min-width: 1000px" @bind-Config="config" @bind-Layout="layout" @bind-Data="data" @ref="chart1" />}

</body>

@code { 

        List<Indicateur> listOfSelectedX = new List<Indicateur>();
        PlotlyChart chart1;

        Config config = new Config();
        Layout layout = new Layout();
    // Using of the interface IList is important for the event callback!
    private IList<ITrace> data = new List<ITrace>
    {
        new Scatter
        {
            Name = "plots",
            Mode = ModeFlag.Lines | ModeFlag.Markers,
            X = new List<object>(),
            Y = new List<object>(),
        }
    };



    public async Task PlotSR(Indicateur indicateur, object e)
    {
        int index = Table.matrixListStatic[0].Indicateurs.FindIndex(i => i.Equals(indicateur));

        IList<object> x = new List<object>() { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 };

        IList<object> y = new List<object>();
        Table.matrixListStatic.ForEach(x => y.Add(x.Indicateurs[index].BetaValueSR));

        Scatter scatter = new Scatter
        {
            Name = $"{Table.matrixListStatic[0].Indicateurs[index].Nom}" + " BetaSR",
            Mode = ModeFlag.Lines | ModeFlag.Markers,
            X = x,
            Y = y
        };

        if ((bool)e)
        {
            await chart1.AddTrace(scatter);

        }
        else
        {
            await chart1.DeleteTrace(scatter);
        }

    }

    public async Task PlotMR(Indicateur indicateur, object e)
    {

        int index = Table.matrixListStatic[0].Indicateurs.FindIndex(i => i.Equals(indicateur));

        IList<object> x = new List<object>() { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 };

        IList<object> y = new List<object>();
        Table.matrixListStatic.ForEach(x => y.Add(x.Indicateurs[index].BetaValueMR));

        Scatter scatter = new Scatter
        {
            Name = $"{Table.matrixListStatic[0].Indicateurs[index].Nom}" + " BetaMR",
            Mode = ModeFlag.Lines | ModeFlag.Markers,
            X = x,
            Y = y
        };

        if ((bool)e)
        {
            await chart1.AddTrace(scatter);

        }
        else
        {
            await chart1.DeleteTrace(scatter);
        }
    }

    protected override async Task OnInitializedAsync()
    {
        if (!NavMenu.firstTime)
        {
            listOfSelectedX = Table.matrixListStatic[0].Indicateurs.ToList().FindAll(x => x.IsChecked);
            listOfSelectedX.Sort((x, y) => y.BetaValueSR.CompareTo(x.BetaValueSR));
        }

    }

}